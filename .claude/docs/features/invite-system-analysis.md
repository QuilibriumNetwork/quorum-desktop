# Invite System Analysis - Comprehensive Report

[â† Back to INDEX](../../INDEX.md)

## Executive Summary

After conducting a detailed analysis of the invite system in the Quorum desktop application, this document provides comprehensive answers to the user's specific questions and outlines the complete architecture of the invite management system.

## Architecture Overview

The invite system operates through several key components:

### Core Components
1. **SpaceEditor.tsx** - Main UI for managing invites (lines 742-907)
2. **useInviteManagement.ts** - Hook managing invite state and logic
3. **useInviteValidation.ts** - Hook for validating invite links
4. **useSpaceJoining.ts** - Hook for joining spaces via invites
5. **MessageDB.tsx** - Core database operations for invites
6. **InviteLink.tsx** - Component for displaying and processing invite links

### Data Flow
1. **Invite Creation**: Generated through `generateNewInviteLink()` in MessageDB.tsx (lines 3829-3869)
2. **Invite Sending**: Sent via `sendInviteToUser()` to direct message conversations (lines 3800-3827)
3. **Invite Processing**: Links parsed and validated through `useInviteValidation` hook
4. **Space Joining**: Users join via `joinInviteLink()` function (lines 4290-4346)

## Detailed Answers to Specific Questions

### 1. Blocks Preventing Users from Receiving Invites in Existing Conversations

**Answer: NO explicit blocks are implemented for kicked users receiving invites.**

**Analysis:**
- The SpaceEditor.tsx invite section (lines 763-784) allows selecting any existing conversation from the dropdown
- The `getUserOptions()` function in useInviteManagement.ts (lines 63-74) returns ALL past conversations without filtering
- There is **no check** to prevent sending invites to previously kicked users
- The system only validates that:
  - A conversation exists between the users
  - The target user address is valid (46 characters, starts with "Qm")

**Code Evidence:**
```typescript
// In useInviteManagement.ts lines 63-74
const getUserOptions = useCallback(() => {
  if (!conversations?.pages) return [];
  return conversations.pages
    .flatMap((c: any) => c.conversations as Conversation[])
    .toReversed()
    .map(conversation => ({
      value: conversation.address,
      label: conversation.displayName,
      avatar: conversation.icon,
      subtitle: conversation.address
    }));
}, [conversations]);
```

**Implication:** Previously kicked users can still receive invite messages in their direct conversations, creating a potential UX issue.

### 2. "Invite Link Expired" Error Messages

**Answer: This error occurs due to cryptographic validation failures, not time-based expiration.**

**Root Causes:**
1. **Invalid Cryptographic Keys**: The invite link contains encrypted space data that requires specific keys for decryption
2. **Key System Conflict**: There are TWO separate key systems - original space keys vs. public link keys
3. **Key Switching**: When public links are generated, the system switches from original keys to new public keys
4. **Missing Configuration**: Space manifest or configuration keys may be missing or corrupted

**Error Flow Analysis:**
- InviteLink.tsx line 26: `setError(t\`Could not verify invite\`)`
- useInviteValidation.ts line 109: `setValidationError(t\`Could not verify invite\`)`
- The error message "The invite link has expired or is invalid" (line 53) is misleading - links don't actually expire by time

**Key Discovery - Two Invite Systems:**
The system actually uses **two different key sources** for invites:

1. **Original Space Keys** (created at space creation):
   - Used by `constructInviteLink()` when NO public link exists
   - Stable and permanent unless public links are enabled

2. **Public Link Keys** (created when public links are enabled):
   - Generated by `generateNewInviteLink()` using new X448 key pairs
   - Replace the original key system once created

**Code Evidence:**
```typescript
// constructInviteLink() - MessageDB.tsx lines 3770-3772
if (space?.inviteUrl) {
  return space.inviteUrl;  // Uses PUBLIC link if it exists
}
// OTHERWISE: Uses original space creation keys
const config_key = await messageDB.getSpaceKey(spaceId, 'config');
```

### 3. "Regenerate Link" Functionality and Private Invites

**Answer: YES, but ONLY if public links have been enabled first.**

**Corrected Understanding:**
1. **Without Public Links**: Private invites use original space keys and remain valid indefinitely
2. **With Public Links**: Once `generateNewInviteLink()` is called, `constructInviteLink()` switches to using public link keys
3. **Key System Switch**: This switch invalidates ALL previous private invites that were using original keys

**How it Actually Works:**
1. **Initial State**: Private invites sent via `sendInviteToUser()` use original space keys through `constructInviteLink()`
2. **Public Link Generation**: When "Generate New Invite Link" is clicked, new X448 keys are created
3. **System Switch**: The `space.inviteUrl` property is set, causing `constructInviteLink()` to use public link keys instead
4. **Invalidation**: Old private invites become invalid because they use the original keys, but the system now expects public keys

**Critical Code Evidence:**
```typescript
// constructInviteLink() decision logic - MessageDB.tsx lines 3768-3796
const constructInviteLink = React.useCallback(async (spaceId: string) => {
  const space = await messageDB.getSpace(spaceId);
  if (space?.inviteUrl) {
    return space.inviteUrl;  // USES PUBLIC KEYS
  }
  
  // ONLY REACHED IF NO PUBLIC LINK EXISTS - USES ORIGINAL KEYS
  const config_key = await messageDB.getSpaceKey(spaceId, 'config');
  const hub_key = await messageDB.getSpaceKey(spaceId, 'hub');
  // ... constructs link with original stable keys
}, []);
```

**User Experience Impact:**
- **Private-Only Spaces**: Private invites never expire - they use stable original keys
- **Mixed Spaces**: Once public linking is enabled, old private invites become invalid
- **Regeneration**: Each regeneration invalidates previous public-era invites
- SpaceEditor.tsx tooltip (line 836) is partially correct but doesn't explain the dual key system

### 4. Kicked Users and Public Invite Link Access

**Answer: YES, kicked users can immediately rejoin via public invite links.**

**Analysis:**
- No persistent "ban list" or "kicked user" database exists
- The `kickUser()` function (MessageDB.tsx lines 3141-3495) only:
  - Removes user from current space member list
  - Sends kick message to space
  - Updates cryptographic keys for remaining members
- Public invite links bypass membership checks entirely

**Security Implications:**
- Kicked users retain the ability to rejoin if they have access to public invite links
- The only permanent prevention would be:
  - Regenerating invite links after kicking
  - Switching to private-only invites
  - Manually managing invite distribution

**Code Evidence:**
```typescript
// No persistent ban list or kicked user tracking found in the codebase
// kickUser() function only handles immediate removal, not future prevention
```

## Technical Architecture Details

### Dual Key System Architecture

**Two Separate Invite Systems:**

1. **Original Space Keys** (Space Creation):
   ```
   Created: When space is first created
   Keys: config_key, hub_key (from space creation)
   Used by: constructInviteLink() when space.inviteUrl is null
   Lifetime: Permanent until public links are enabled
   ```

2. **Public Link Keys** (On-Demand Generation):
   ```
   Created: When generateNewInviteLink() is called
   Keys: New X448 key pairs + updated config
   Used by: constructInviteLink() when space.inviteUrl exists
   Lifetime: Until regenerated
   ```

### Invite Link Structures

**Private Invites (Original Keys):**
```
https://qm.one/#spaceId={SPACE_ID}&configKey={ORIGINAL_CONFIG_PRIVATE_KEY}&template={TEMPLATE}&secret={SECRET}&hubKey={HUB_PRIVATE_KEY}
```

**Public Links (Generated Keys):**
```
https://qm.one/invite/#spaceId={SPACE_ID}&configKey={NEW_CONFIG_PRIVATE_KEY}
```

### Cryptographic Flow

**Private Invites (constructInviteLink):**
1. **Check**: Does `space.inviteUrl` exist?
2. **If NO**: Use original space creation keys
3. **Template Construction**: Uses existing encryption states and ratchets
4. **Link Generation**: Includes template, secret, and hub keys
5. **Validation**: Uses original config keys for decryption

**Public Links (generateNewInviteLink):**
1. **Key Generation**: Create new X448 key pair
2. **Key Storage**: Save new config keys to database
3. **Space Update**: Set `space.inviteUrl` with new link
4. **Manifest Creation**: Encrypt space data with new keys
5. **Validation**: Uses new config keys for decryption

### Key Decision Logic
```typescript
// The critical decision point in constructInviteLink()
if (space?.inviteUrl) {
  return space.inviteUrl;  // PUBLIC SYSTEM
} else {
  // PRIVATE SYSTEM - use original keys
  const config_key = await messageDB.getSpaceKey(spaceId, 'config');
  const hub_key = await messageDB.getSpaceKey(spaceId, 'hub');
}
```

### Database Operations
- **Space Keys**: Multiple types stored ('hub', 'owner', 'config', 'space')
- **Key Evolution**: Original keys preserved, new keys added when public links enabled
- **Space State**: `inviteUrl` property determines which key system is active
- **Member Management**: Real-time updates via WebSocket sync
- **Message History**: Persistent storage in local MessageDB

## Recommendations

### Security Improvements
1. **Implement Kicked User Tracking**: Create persistent ban list to prevent re-joining
2. **Enhanced Validation**: Add kicked user checks in invite processing
3. **Key System Warning**: Alert users that enabling public links invalidates private invites
4. **Separate Key Systems**: Consider maintaining both key systems simultaneously

### UX Improvements
1. **Better Error Messages**: Distinguish between expired, invalid, and access-denied scenarios
2. **Kicked User Notifications**: Clear indication when users are blocked from spaces
3. **Invite History**: Track sent invites and their status
4. **Key System Education**: Explain the difference between private and public invite systems
5. **Migration Warning**: Warn users before switching from private-only to public linking

### Code Quality
1. **Centralized Validation**: Move invite validation logic to single location
2. **Type Safety**: Improve TypeScript definitions for invite-related types
3. **Error Handling**: More granular error categorization and handling
4. **Documentation**: Better code comments explaining the dual key system

### Critical UX Issues to Address
1. **Hidden Key Switch**: Users don't understand that enabling public links breaks private invites
2. **Misleading Tooltips**: Current tooltip doesn't explain the dual system impact
3. **No Rollback**: Once public links are enabled, there's no way to go back to private-only mode

## Conclusion

The invite system uses a sophisticated **dual key architecture** that provides flexibility but creates significant UX confusion. The key findings are:

1. **Private invites CAN be permanent** - they use stable space creation keys
2. **"Expiration" is really key system switching** - not time-based expiration
3. **Public link generation is a one-way operation** - it permanently changes how invites work
4. **Kicked users have no persistent blocks** - they can easily rejoin

The system is cryptographically sound but the UX around key system transitions needs significant improvement to prevent user confusion and accidental invite invalidation.

---

*Document created: July 30, 2025*
*Analysis covers: SpaceEditor.tsx, useInviteManagement.ts, useInviteValidation.ts, useSpaceJoining.ts, MessageDB.tsx, InviteLink.tsx*