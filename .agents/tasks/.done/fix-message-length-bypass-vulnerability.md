---
type: task
title: Fix Message Length Limit Bypass Vulnerability
status: done
complexity: medium
ai_generated: true
created: 2025-12-11T00:00:00.000Z
updated: '2026-01-09'
---

# Fix Message Length Limit Bypass Vulnerability

> **âš ï¸ AI-Generated**: May contain errors. Verify before use.
> **Reviewed by**: security-analyst agent, feature-analyzer agent


**Related**: `.temp/client-side-limitations-bypass-audit_2025-12-11.md`, `tasks/fix-read-only-channel-bypass-vulnerability.md`

## What & Why

**Current State**: Message length limit (2500 characters) is enforced client-side only in React validation hooks. Custom clients or DevTools manipulation can bypass this limit and send extremely long messages (100K+ characters) that propagate to all users on official clients, causing UI degradation and potential denial-of-service.

**Desired State**: Add receiving-side validation in MessageService that rejects oversized messages before adding them to the query cache, following the same defense-in-depth pattern successfully applied to the read-only channel bypass fix (2025-12-11).

**Value**: Protects all space members from UI performance issues, memory consumption problems, and potential DoS attacks. Completes the defense-in-depth security model for input validation limits (complementing permission-based protections).

## Context

**Security Impact**: MEDIUM severity
- Affects all users on official clients (network-propagated vulnerability)
- No defense-in-depth currently exists (unlike permissions which have receiving-side validation)
- Can cause browser performance degradation, memory issues, and storage bloat
- Enables denial-of-service when combined with lack of rate limiting

**Existing Pattern**: The read-only channel fix (2025-12-11) established the successful pattern:
- Receiving-side validation in `MessageService.ts:821-879`
- Validation occurs BEFORE `queryClient.setQueryData()` at line 882
- Messages that fail validation are silently dropped (logged but not displayed)
- Fail-secure approach: reject when data unavailable

**Related Vulnerability**: Mention count limit (20 per message) has identical vulnerability pattern and should be fixed simultaneously with the same approach.

**Files**:
- `src/services/MessageService.ts:821-910` - Message receiving logic (add validation here)
- `src/utils/validation.ts:56` - `MAX_MESSAGE_LENGTH = 2500` constant
- `src/utils/mentionUtils.ts:197` - `MAX_MENTIONS_PER_MESSAGE = 20` constant
- `src/hooks/business/validation/useMessageValidation.ts:10-31` - Client-side validation (existing)
- `src/hooks/business/messages/useMessageComposer.ts:155-158` - UI submission guard (existing)

## Prerequisites

- [ ] Review `.temp/client-side-limitations-bypass-audit_2025-12-11.md` for full vulnerability context
- [ ] Review `tasks/fix-read-only-channel-bypass-vulnerability.md` for reference pattern (read-only fix)
- [ ] Examine `MessageService.ts:821-879` to understand existing receiving-side validation pattern
- [ ] Security analysis by security-analyst agent completed (this document)
- [ ] No conflicting PRs modifying MessageService message processing

## Implementation

### Phase 1: Add Receiving-Side Validation (Primary Fix)

**Goal**: Reject oversized messages and excessive mentions BEFORE adding to query cache, following the read-only channel pattern.

#### Step 1.1: Add Import Statements
**Location**: `src/services/MessageService.ts` (top of file)

Add required imports for validation constants (verify these don't already exist):

```typescript
import { MAX_MESSAGE_LENGTH } from '../utils/validation';
import { MAX_MENTIONS_PER_MESSAGE } from '../utils/mentionUtils';
```

**Done when**: Constants imported and available in MessageService
**Verify**: No "Cannot find name" TypeScript errors

#### Step 1.2: Add Validation Logic in MessageService
**Location**: `src/services/MessageService.ts:879-882`

Add validation immediately **after** the read-only channel validation block (which ends at line 879) and **before** the `queryClient.setQueryData` call (line 882).

**IMPORTANT**: Both `PostMessage.text` and `EditMessage.editedText` can be `string | string[]`, so we must handle arrays:

```typescript
// After read-only channel validation (line 879)
}
// BEFORE queryClient.setQueryData (line 882)

// Message length validation (defense-in-depth)
// Note: text and editedText can be string | string[], must handle both
if (isValidatableType) {
  let messageText: string | undefined;

  if (decryptedContent.content.type === 'post') {
    const text = (decryptedContent.content as PostMessage).text;
    messageText = Array.isArray(text) ? text.join('') : text;
  } else if (decryptedContent.content.type === 'edit-message') {
    const editedText = (decryptedContent.content as EditMessage).editedText;
    messageText = Array.isArray(editedText) ? editedText.join('') : editedText;
  }

  if (messageText && messageText.length > MAX_MESSAGE_LENGTH) {
    console.log(
      `ðŸ”’ Rejecting oversized message ${decryptedContent.messageId} ` +
      `from ${decryptedContent.content.senderId} ` +
      `(${messageText.length} chars > ${MAX_MESSAGE_LENGTH} limit)`
    );
    return; // Drop the message
  }
}

// Mention count validation (defense-in-depth)
if (decryptedContent.mentions) {
  const totalMentions =
    (decryptedContent.mentions.memberIds?.length || 0) +
    (decryptedContent.mentions.roleIds?.length || 0) +
    (decryptedContent.mentions.channelIds?.length || 0) +
    (decryptedContent.mentions.everyone ? 1 : 0);

  if (totalMentions > MAX_MENTIONS_PER_MESSAGE) {
    console.log(
      `ðŸ”’ Rejecting message ${decryptedContent.messageId} ` +
      `from ${decryptedContent.content.senderId} ` +
      `with excessive mentions (${totalMentions} > ${MAX_MENTIONS_PER_MESSAGE})`
    );
    return; // Drop the message
  }
}

// Authorized - add to cache (existing line 882)
queryClient.setQueryData(
```

**Done when**:
- Validation code added in correct location
- Both `post` and `edit-message` types are validated
- Array text fields are properly joined before length check
- Messages exceeding limits are dropped with clear log messages
- No TypeScript errors

**Verify**:
- Code compiles: `npx tsc --noEmit`
- Logic follows read-only channel pattern exactly
- Edit message bypass is also blocked

### Phase 2: Optional Service-Layer Validation (Defense in Depth)

**Note**: This is **optional** hardening. The receiving-side validation in Phase 1 is the critical security control. This adds defense-in-depth by preventing the honest client from even sending oversized messages.

#### Step 2.1: Add Validation Helper Function
**Location**: `src/services/MessageService.ts` (add near top of class or as private method)

Create a helper to avoid code duplication and properly handle `string | string[]` types:

```typescript
/**
 * Validates message length for defense-in-depth at service layer.
 * Handles both string and string[] text formats.
 * @throws Error if message exceeds MAX_MESSAGE_LENGTH
 */
private validateMessageLength(pendingMessage: string | object): void {
  let textToValidate: string | undefined;

  if (typeof pendingMessage === 'string') {
    textToValidate = pendingMessage;
  } else if ((pendingMessage as any).text) {
    const text = (pendingMessage as any).text;
    textToValidate = Array.isArray(text) ? text.join('') : text;
  } else if ((pendingMessage as any).editedText) {
    const editedText = (pendingMessage as any).editedText;
    textToValidate = Array.isArray(editedText) ? editedText.join('') : editedText;
  }

  if (textToValidate && textToValidate.length > MAX_MESSAGE_LENGTH) {
    console.warn(`Message exceeds ${MAX_MESSAGE_LENGTH} character limit`);
    throw new Error(`Message too long (${textToValidate.length} chars)`);
  }
}
```

#### Step 2.2: Add Validation in submitChannelMessage
**Location**: `src/services/MessageService.ts:2720-2730`

Add validation immediately after the space fetch (line 2723) and before processing begins:

```typescript
async submitChannelMessage(
  spaceId: string,
  channelId: string,
  pendingMessage: string | object,
  // ... other parameters
) {
  this.enqueueOutbound(async () => {
    const outbounds: string[] = [];
    const nonce = crypto.randomUUID();
    const space = await this.messageDB.getSpace(spaceId);

    // Validate message length before processing (defense-in-depth)
    this.validateMessageLength(pendingMessage);

    // Handle edit-message type (existing code continues)
    if (
      typeof pendingMessage === 'object' &&
      (pendingMessage as any).type === 'edit-message'
    ) {
```

**Done when**: Service layer rejects oversized messages before encryption
**Verify**: Honest clients cannot accidentally send oversized messages

#### Step 2.3: Add Validation in submitMessage (DMs)
**Location**: `src/services/MessageService.ts:983-990`

Apply same validation for direct messages:

```typescript
async submitMessage(
  address: string,
  pendingMessage: string | object,
  // ... other parameters
) {
  this.enqueueOutbound(async () => {
    const outbounds: string[] = [];
    const nonce = crypto.randomUUID();

    // Validate message length before processing (defense-in-depth)
    this.validateMessageLength(pendingMessage);

    // Handle edit-message type (existing code continues)
```

**Done when**: DM submissions also validate length
**Verify**: Both channels and DMs protected at service layer

## Verification

### Test 1: Receiving-Side Validation (Critical)
**Test Steps**:
1. Create a test that simulates receiving an oversized message
2. Mock `decryptedContent` with text length > 2500 characters
3. Call the message processing logic
4. Verify message is NOT added to query cache
5. Verify rejection logged to console with correct format

**Expected Result**: Oversized messages dropped, logged, never displayed

**Manual Test**:
1. Use browser DevTools to simulate custom client behavior
2. Attempt to submit 5000 character message
3. Verify it appears only in sender's view
4. Verify it does NOT appear in another user's view on official client

### Test 2: Mention Count Validation
**Test Steps**:
1. Create message with 25 user mentions
2. Verify receiving-side validation rejects it
3. Confirm logged with correct message count

**Expected Result**: Messages with >20 mentions dropped

### Test 3: Edit Message Validation
**Test Steps**:
1. Edit existing message to exceed 2500 characters
2. Verify edit is rejected on receiving side
3. Original message remains unchanged

**Expected Result**: Oversized edits rejected, original message preserved

### Test 4: TypeScript Compilation
**Command**: `npx tsc --noEmit`
**Expected Result**: No type errors

### Test 5: Service-Layer Validation (Optional)
**Test Steps**:
1. If Phase 2 implemented, test that submitChannelMessage rejects long messages
2. Verify error thrown with descriptive message
3. Test both string messages and object messages with text property

**Expected Result**: Service layer prevents submission of oversized messages

## Architecture Notes

### Why Receiving-Side Validation is Critical

In a decentralized P2P messaging system:
- **No central authority** to enforce limits before broadcast
- **Encrypted DHT** means messages are propagated network-wide
- **Client-side validation alone** is insufficient (custom clients bypass)
- **Receiving-side validation** is the ONLY way to protect official clients

### Pattern Consistency

This fix follows the **exact same pattern** as three other successful receiving-side validations:

1. **Read-only channels** (2025-12-11): Receiving clients validate post permissions
2. **Delete messages**: Receiving clients validate delete permissions
3. **@everyone mentions**: Stripped at send time before broadcast

The pattern is:
```
1. Decrypt message
2. Validate BEFORE adding to query cache
3. Silent rejection with logging
4. Fail-secure: reject if uncertain
```

### Non-Text Message Types

**Stickers, reactions, and other message types** do not have text content to validate and are correctly excluded from length validation by the `isValidatableType` check. These message types have their own constraints enforced elsewhere in the codebase.

### Why Hard Rejection (Not Truncation)

**Considered**: Truncate oversized messages to 2500 chars with "[Message truncated]" indicator

**Rejected because**:
- More complex implementation
- Confusing UX (sender sees full message, others see truncated)
- Inconsistent with permission validation pattern
- Could enable "hidden message" attacks (sensitive info after truncation point)

**Chosen**: Hard rejection (drop message completely) for:
- Simplicity and consistency
- Clear security boundary
- Predictable behavior
- Same pattern as read-only channel fix

## Security Considerations

### Attack Scenarios Mitigated

1. **UI Denial-of-Service**:
   - Attack: Flood channel with 100K character messages
   - Mitigation: Receiving-side drops them, UI unaffected

2. **Browser Resource Exhaustion**:
   - Attack: Send messages that cause browser lag/freezing
   - Mitigation: Messages never reach rendering layer

3. **Storage Quota Attacks**:
   - Attack: Fill IndexedDB with massive messages
   - Mitigation: Oversized messages never stored

4. **Notification Spam** (mentions):
   - Attack: Send message with 100+ mentions
   - Mitigation: Messages with >20 mentions dropped

### What This Does NOT Fix

- **Rate limiting**: Still needed (separate issue documented in audit)
- **DDoS at network layer**: P2P network flooding (outside client scope)
- **Message spam with valid lengths**: Rate limiting required

### Privacy Impact

- **Minimal metadata leakage**: Message length itself is minimal metadata
- **No additional tracking**: Rejection is silent (no receipt sent to sender)
- **Encryption preserved**: Messages still encrypted in transit
- **No new correlation risks**: Rejection happens after decryption

## Definition of Done

- [ ] Phase 1 (receiving-side validation) implemented and tested
- [ ] Import statements added for validation constants
- [ ] Both message length and mention count validation working
- [ ] Edit messages also validated
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
- [ ] Manual testing confirms oversized messages dropped on receiving side
- [ ] Console logging provides clear rejection messages
- [ ] Code follows exact pattern from read-only channel fix
- [ ] Phase 2 (optional service-layer validation) implemented if desired
- [ ] No regression in existing message functionality
- [ ] Task updated with implementation notes and learnings

## Related Documentation

- **Audit Report**: `.temp/client-side-limitations-bypass-audit_2025-12-11.md` (full vulnerability analysis)
- **Reference Fix**: `tasks/fix-read-only-channel-bypass-vulnerability.md` (same pattern)
- **Validation System**: `docs/features/input-validation-reference.md`
- **Message Service**: `src/services/MessageService.ts:821-910` (receiving logic)
- **Security Architecture**: `docs/features/security.md`

## Implementation Notes

- Date: 2025-12-11 - **Feature-analyzer review**: Fixed critical bugs in code snippets:
  1. Changed `newText` to correct field name `editedText` (from `EditMessage` type)
  2. Added array handling for `string | string[]` types (`text` and `editedText` can be arrays)
  3. Consolidated Steps 1.1/1.3 into single complete code block
  4. Phase 2 refactored with helper function to avoid duplication and properly handle all cases
  5. Added documentation for non-text message types (stickers, reactions excluded from validation)

---


_Security Impact: MEDIUM - Affects all users on official clients_
_Pattern: Defense-in-depth receiving-side validation_
